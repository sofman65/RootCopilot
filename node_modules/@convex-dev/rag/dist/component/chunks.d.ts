import { type Infer } from "convex/values";
import { type Entry } from "../shared.js";
import type { Id } from "./_generated/dataModel.js";
import { type MutationCtx } from "./_generated/server.js";
export declare const vInsertChunksArgs: import("convex/values").VObject<{
    entryId: import("convex/values").GenericId<"entries">;
    startOrder: number;
    chunks: {
        searchableText?: string | undefined;
        content: {
            metadata?: Record<string, any> | undefined;
            text: string;
        };
        embedding: number[];
    }[];
}, {
    entryId: import("convex/values").VId<import("convex/values").GenericId<"entries">, "required">;
    startOrder: import("convex/values").VFloat64<number, "required">;
    chunks: import("convex/values").VArray<{
        searchableText?: string | undefined;
        content: {
            metadata?: Record<string, any> | undefined;
            text: string;
        };
        embedding: number[];
    }[], import("convex/values").VObject<{
        searchableText?: string | undefined;
        content: {
            metadata?: Record<string, any> | undefined;
            text: string;
        };
        embedding: number[];
    }, {
        content: import("convex/values").VObject<{
            metadata?: Record<string, any> | undefined;
            text: string;
        }, {
            text: import("convex/values").VString<string, "required">;
            metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
        }, "required", "text" | "metadata" | `metadata.${string}`>;
        embedding: import("convex/values").VArray<number[], import("convex/values").VFloat64<number, "required">, "required">;
        searchableText: import("convex/values").VString<string | undefined, "optional">;
    }, "required", "content" | "embedding" | "searchableText" | "content.text" | "content.metadata" | `content.metadata.${string}`>, "required">;
}, "required", "entryId" | "startOrder" | "chunks">;
type InsertChunksArgs = Infer<typeof vInsertChunksArgs>;
export declare const insert: import("convex/server").RegisteredMutation<"public", {
    entryId: import("convex/values").GenericId<"entries">;
    startOrder: number;
    chunks: {
        searchableText?: string | undefined;
        content: {
            metadata?: Record<string, any> | undefined;
            text: string;
        };
        embedding: number[];
    }[];
}, Promise<{
    status: "pending" | "ready";
}>>;
export declare function insertChunks(ctx: MutationCtx, { entryId, startOrder, chunks }: InsertChunksArgs): Promise<{
    status: "pending" | "ready";
}>;
export declare const replaceChunksPage: import("convex/server").RegisteredMutation<"public", {
    entryId: import("convex/values").GenericId<"entries">;
    startOrder: number;
}, Promise<{
    status: "replaced";
    nextStartOrder: number;
} | {
    status: "pending";
    nextStartOrder: number;
} | {
    status: "ready";
    nextStartOrder: number;
}>>;
export declare const vRangeResult: import("convex/values").VObject<{
    entryId: import("convex/values").GenericId<"entries">;
    order: number;
    content: {
        metadata?: Record<string, any> | undefined;
        text: string;
    }[];
    startOrder: number;
}, {
    entryId: import("convex/values").VId<import("convex/values").GenericId<"entries">, "required">;
    order: import("convex/values").VFloat64<number, "required">;
    startOrder: import("convex/values").VFloat64<number, "required">;
    content: import("convex/values").VArray<{
        metadata?: Record<string, any> | undefined;
        text: string;
    }[], import("convex/values").VObject<{
        metadata?: Record<string, any> | undefined;
        text: string;
    }, {
        text: import("convex/values").VString<string, "required">;
        metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
    }, "required", "text" | "metadata" | `metadata.${string}`>, "required">;
}, "required", "entryId" | "order" | "content" | "startOrder">;
export declare const getRangesOfChunks: import("convex/server").RegisteredQuery<"internal", {
    chunkContext: {
        before: number;
        after: number;
    };
    embeddingIds: import("convex/values").GenericId<"vectors_4096" | "vectors_128" | "vectors_256" | "vectors_512" | "vectors_768" | "vectors_1024" | "vectors_1408" | "vectors_1536" | "vectors_2048" | "vectors_3072">[];
}, Promise<{
    ranges: (null | Infer<typeof vRangeResult>)[];
    entries: Entry[];
}>>;
export declare const list: import("convex/server").RegisteredQuery<"public", {
    entryId: import("convex/values").GenericId<"entries">;
    order: "desc" | "asc";
    paginationOpts: {
        id?: number;
        endCursor?: string | null;
        maximumRowsRead?: number;
        maximumBytesRead?: number;
        numItems: number;
        cursor: string | null;
    };
}, Promise<{
    page: {
        order: number;
        state: "pending" | "ready" | "replaced";
        text: string;
        metadata: Record<string, any> | undefined;
    }[];
    isDone: boolean;
    continueCursor: import("convex/server").Cursor;
    splitCursor?: import("convex/server").Cursor | null;
    pageStatus?: "SplitRecommended" | "SplitRequired" | null;
}>>;
export declare const deleteChunksPage: import("convex/server").RegisteredMutation<"internal", {
    entryId: Id<"entries">;
    startOrder: number;
}, Promise<{
    isDone: boolean;
    nextStartOrder: number;
}>>;
export declare function deleteChunksPageHandler(ctx: MutationCtx, { entryId, startOrder }: {
    entryId: Id<"entries">;
    startOrder: number;
}): Promise<{
    isDone: boolean;
    nextStartOrder: number;
}>;
export {};
//# sourceMappingURL=chunks.d.ts.map