import { getVectorTableName, validateVectorDimension } from "./tables.js";
import { filterFieldsFromNumbers } from "../filters.js";
import { searchVector, vectorWithImportance } from "./importance.js";
// TODO: wait to see if this is needed.
// export const insertBatch = mutation({
//   args: {
//     vectorDimension: vVectorDimension,
//     vectors: v.array(
//       v.object({
//         vector: v.array(v.number()),
//         namespace: v.id("namespaces"),
//         importance: v.optional(v.number()),
//         filters: v.optional(v.any()),
//       })
//     ),
//   },
//   returns: v.array(vVectorId),
//   handler: async (ctx, args) => {
//     return Promise.all(
//       args.vectors.map(async (vector) =>
//         insertEmbedding(
//           ctx,
//           vector.vector,
//           vector.namespace,
//           vector.importance,
//           vector.filters
//         )
//       )
//     );
//   },
// });
export async function insertEmbedding(ctx, embedding, namespaceId, importance, filters) {
    const filterFields = filterFieldsFromNumbers(namespaceId, filters);
    const dimension = validateVectorDimension(embedding.length);
    return ctx.db.insert(getVectorTableName(dimension), {
        namespaceId,
        vector: vectorWithImportance(embedding, importance ?? 1),
        ...filterFields,
    });
}
export async function searchEmbeddings(ctx, { embedding, namespaceId, filters, limit, }) {
    const dimension = validateVectorDimension(embedding.length);
    const tableName = getVectorTableName(dimension);
    const orFilters = filters.flatMap((filter) => filterFieldsFromNumbers(namespaceId, filter));
    return ctx.vectorSearch(tableName, "vector", {
        vector: searchVector(embedding),
        filter: (q) => orFilters.length === 0
            ? q.eq("namespaceId", namespaceId)
            : q.or(...orFilters.flatMap((namedFilter) => Object.entries(namedFilter).map(([filterField, filter]) => q.eq(filterField, filter)))),
        limit,
    });
}
//# sourceMappingURL=index.js.map