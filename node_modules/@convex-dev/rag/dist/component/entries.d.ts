import { PaginationResult } from "convex/server";
import { type Value } from "convex/values";
import type { EntryFilter } from "../shared.js";
import { type Entry } from "../shared.js";
import type { Doc, Id } from "./_generated/dataModel.js";
import { type QueryCtx } from "./_generated/server.js";
import { type StatusWithOnComplete } from "./schema.js";
export declare const addAsync: import("convex/server").RegisteredMutation<"public", {
    onComplete?: string | undefined;
    entry: {
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        namespaceId: import("convex/values").GenericId<"namespaces">;
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    };
    chunker: string;
}, Promise<{
    entryId: import("convex/values").GenericId<"entries">;
    status: "ready";
    created: boolean;
} | {
    entryId: import("convex/values").GenericId<"entries">;
    status: "pending";
    created: boolean;
}>>;
export declare const addAsyncOnComplete: import("convex/server").RegisteredMutation<"internal", {
    workId: import("@convex-dev/workpool").WorkId;
    result: {
        kind: "success";
        returnValue: any;
    } | {
        kind: "failed";
        error: string;
    } | {
        kind: "canceled";
    };
    context: import("convex/values").GenericId<"entries">;
}, Promise<void>>;
export declare const add: import("convex/server").RegisteredMutation<"public", {
    allChunks?: {
        searchableText?: string | undefined;
        content: {
            metadata?: Record<string, any> | undefined;
            text: string;
        };
        embedding: number[];
    }[] | undefined;
    onComplete?: string | undefined;
    entry: {
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        namespaceId: import("convex/values").GenericId<"namespaces">;
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    };
}, Promise<{
    entryId: import("convex/values").GenericId<"entries">;
    status: "pending" | "ready";
    created: boolean;
}>>;
/**
 * Lists entries in order of their most recent change
 */
export declare const list: import("convex/server").RegisteredQuery<"public", {
    namespaceId?: import("convex/values").GenericId<"namespaces"> | undefined;
    order?: "desc" | "asc" | undefined;
    status: "pending" | "ready" | "replaced";
    paginationOpts: {
        id?: number;
        endCursor?: string | null;
        maximumRowsRead?: number;
        maximumBytesRead?: number;
        numItems: number;
        cursor: string | null;
    };
}, Promise<PaginationResult<Entry>>>;
/**
 * Gets a entry by its id.
 */
export declare const get: import("convex/server").RegisteredQuery<"public", {
    entryId: import("convex/values").GenericId<"entries">;
}, Promise<Entry | null>>;
/**
 * Finds a entry by its key and content hash.
 */
export declare const findByContentHash: import("convex/server").RegisteredQuery<"public", {
    namespace: string;
    filterNames: string[];
    dimension: number;
    modelId: string;
    key: string;
    contentHash: string;
}, Promise<Entry | null>>;
/**
 * Promotes a entry to ready, replacing any existing ready entry by key.
 * It will also call the associated onComplete function if it was pending.
 * Note: this will not replace the chunks automatically, so you should first
 * call `replaceChunksPage` on all its chunks.
 * Edge case: if the entry has already been replaced, it will return the
 * same entry (replacedEntry.entryId === args.entryId).
 */
export declare const promoteToReady: import("convex/server").RegisteredMutation<"public", {
    entryId: Id<"entries">;
}, Promise<{
    replacedEntry: Entry | null;
}>>;
export declare function getPreviousEntry(ctx: QueryCtx, entry: Doc<"entries">): Promise<{
    _id: import("convex/values").GenericId<"entries">;
    _creationTime: number;
    metadata?: Record<string, any> | undefined;
    key?: string | undefined;
    title?: string | undefined;
    contentHash?: string | undefined;
    namespaceId: import("convex/values").GenericId<"namespaces">;
    status: {
        onComplete?: string | undefined;
        kind: "pending";
    } | {
        kind: "ready";
    } | {
        replacedAt: number;
        kind: "replaced";
    };
    version: number;
    importance: number;
    filterValues: {
        name: string;
        value: any;
    }[];
} | null>;
export declare function publicEntry(entry: {
    _id: Id<"entries">;
    key?: string | undefined;
    importance: number;
    filterValues: EntryFilter[];
    contentHash?: string | undefined;
    title?: string | undefined;
    metadata?: Record<string, Value> | undefined;
    status: StatusWithOnComplete;
}): Entry;
export declare const deleteAsync: import("convex/server").RegisteredMutation<"public", {
    entryId: Id<"entries">;
    startOrder: number;
}, Promise<void>>;
export declare const deleteSync: import("convex/server").RegisteredAction<"public", {
    entryId: import("convex/values").GenericId<"entries">;
}, Promise<void>>;
export declare const _del: import("convex/server").RegisteredMutation<"internal", {
    entryId: import("convex/values").GenericId<"entries">;
}, Promise<void>>;
export declare const deleteByKeyAsync: import("convex/server").RegisteredMutation<"public", {
    beforeVersion?: number | undefined;
    namespaceId: import("convex/values").GenericId<"namespaces">;
    key: string;
}, Promise<void>>;
export declare const getEntriesForNamespaceByKey: import("convex/server").RegisteredQuery<"internal", {
    namespaceId: Id<"namespaces">;
    key: string;
    beforeVersion?: number;
}, Promise<{
    _id: import("convex/values").GenericId<"entries">;
    _creationTime: number;
    metadata?: Record<string, any> | undefined;
    key?: string | undefined;
    title?: string | undefined;
    contentHash?: string | undefined;
    namespaceId: import("convex/values").GenericId<"namespaces">;
    status: {
        onComplete?: string | undefined;
        kind: "pending";
    } | {
        kind: "ready";
    } | {
        replacedAt: number;
        kind: "replaced";
    };
    version: number;
    importance: number;
    filterValues: {
        name: string;
        value: any;
    }[];
}[]>>;
export declare const deleteByKeySync: import("convex/server").RegisteredAction<"public", {
    namespaceId: import("convex/values").GenericId<"namespaces">;
    key: string;
}, Promise<void>>;
//# sourceMappingURL=entries.d.ts.map