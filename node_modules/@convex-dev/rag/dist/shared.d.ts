import type { GenericId, Infer, Validator, Value, VObject } from "convex/values";
import { type NamedFilter } from "./component/filters.js";
import type { FunctionReference } from "convex/server";
export declare const CHUNK_BATCH_SIZE = 100;
export declare const vNamespaceId: import("convex/values").VString<string & {
    _: "NamespaceId";
}, "required">;
export declare const vEntryId: import("convex/values").VString<string & {
    _: "EntryId";
}, "required">;
export type NamespaceId = Infer<typeof vNamespaceId>;
export type EntryId = Infer<typeof vEntryId>;
export declare const vSearchResult: VObject<{
    entryId: string & {
        _: "EntryId";
    };
    order: number;
    content: {
        metadata?: Record<string, any> | undefined;
        text: string;
    }[];
    startOrder: number;
    score: number;
}, {
    entryId: import("convex/values").VString<string & {
        _: "EntryId";
    }, "required">;
    order: import("convex/values").VFloat64<number, "required">;
    content: import("convex/values").VArray<{
        metadata?: Record<string, any> | undefined;
        text: string;
    }[], VObject<{
        metadata?: Record<string, any> | undefined;
        text: string;
    }, {
        text: import("convex/values").VString<string, "required">;
        metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
    }, "required", "text" | "metadata" | `metadata.${string}`>, "required">;
    startOrder: import("convex/values").VFloat64<number, "required">;
    score: import("convex/values").VFloat64<number, "required">;
}, "required", "entryId" | "order" | "content" | "startOrder" | "score">;
export type SearchResult = Infer<typeof vSearchResult>;
export declare const vStatus: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
export declare const vActiveStatus: import("convex/values").VUnion<"pending" | "ready", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">], "required", never>;
export type Status = Infer<typeof vStatus>;
export declare const statuses: ("pending" | "ready" | "replaced")[];
export declare const vNamespace: VObject<{
    namespaceId: string & {
        _: "NamespaceId";
    };
    createdAt: number;
    namespace: string;
    status: "pending" | "ready" | "replaced";
    filterNames: string[];
    dimension: number;
    modelId: string;
    version: number;
}, {
    namespaceId: import("convex/values").VString<string & {
        _: "NamespaceId";
    }, "required">;
    createdAt: import("convex/values").VFloat64<number, "required">;
    namespace: import("convex/values").VString<string, "required">;
    status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
    filterNames: import("convex/values").VArray<string[], import("convex/values").VString<string, "required">, "required">;
    dimension: import("convex/values").VFloat64<number, "required">;
    modelId: import("convex/values").VString<string, "required">;
    version: import("convex/values").VFloat64<number, "required">;
}, "required", "namespaceId" | "createdAt" | "namespace" | "status" | "filterNames" | "dimension" | "modelId" | "version">;
export type Namespace = Infer<typeof vNamespace>;
export declare const vEntry: VObject<{
    metadata?: Record<string, any> | undefined;
    key?: string | undefined;
    title?: string | undefined;
    contentHash?: string | undefined;
    replacedAt?: number | undefined;
    entryId: string & {
        _: "EntryId";
    };
    status: "pending" | "ready" | "replaced";
    importance: number;
    filterValues: {
        name: string;
        value: any;
    }[];
}, {
    key: import("convex/values").VString<string | undefined, "optional">;
    title: import("convex/values").VString<string | undefined, "optional">;
    metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
    entryId: import("convex/values").VString<string & {
        _: "EntryId";
    }, "required">;
    importance: import("convex/values").VFloat64<number, "required">;
    filterValues: import("convex/values").VArray<{
        name: string;
        value: any;
    }[], VObject<{
        name: string;
        value: any;
    }, {
        name: import("convex/values").VString<string, "required">;
        value: import("convex/values").VAny<any, "required", string>;
    }, "required", "name" | "value" | `value.${string}`>, "required">;
    contentHash: import("convex/values").VString<string | undefined, "optional">;
    status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
    replacedAt: import("convex/values").VFloat64<number | undefined, "optional">;
}, "required", "entryId" | "metadata" | `metadata.${string}` | "status" | "key" | "title" | "importance" | "filterValues" | "contentHash" | "replacedAt">;
export type VEntry<Filters extends Record<string, Value>, Metadata extends Record<string, Value>> = VObject<Entry<Filters, Metadata>, typeof vEntry.fields, "required", typeof vEntry.fieldPaths>;
export declare const vSearchEntry: VObject<{
    metadata?: Record<string, any> | undefined;
    key?: string | undefined;
    title?: string | undefined;
    contentHash?: string | undefined;
    replacedAt?: number | undefined;
    entryId: string & {
        _: "EntryId";
    };
    text: string;
    status: "pending" | "ready" | "replaced";
    importance: number;
    filterValues: {
        name: string;
        value: any;
    }[];
}, {
    text: import("convex/values").VString<string, "required">;
    key: import("convex/values").VString<string | undefined, "optional">;
    title: import("convex/values").VString<string | undefined, "optional">;
    metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
    entryId: import("convex/values").VString<string & {
        _: "EntryId";
    }, "required">;
    importance: import("convex/values").VFloat64<number, "required">;
    filterValues: import("convex/values").VArray<{
        name: string;
        value: any;
    }[], VObject<{
        name: string;
        value: any;
    }, {
        name: import("convex/values").VString<string, "required">;
        value: import("convex/values").VAny<any, "required", string>;
    }, "required", "name" | "value" | `value.${string}`>, "required">;
    contentHash: import("convex/values").VString<string | undefined, "optional">;
    status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
    replacedAt: import("convex/values").VFloat64<number | undefined, "optional">;
}, "required", "entryId" | "text" | "metadata" | `metadata.${string}` | "status" | "key" | "title" | "importance" | "filterValues" | "contentHash" | "replacedAt">;
export type VSearchEntry<Filters extends Record<string, Value>, Metadata extends Record<string, Value>> = VObject<SearchEntry<Filters, Metadata>, typeof vSearchEntry.fields, "required", typeof vSearchEntry.fieldPaths>;
export type SearchEntry<Filters extends Record<string, Value>, Metadata extends Record<string, Value>> = Entry<Filters, Metadata> & {
    text: string;
};
export type EntryFilter<Filters extends Record<string, Value> = Record<string, Value>> = {
    [K in keyof Filters & string]: NamedFilter<K, Filters[K]>;
}[keyof Filters & string];
export type Entry<Filters extends Record<string, Value> = any, Metadata extends Record<string, Value> = any> = {
    /** The entry's id, uniquely identifying the key + contents + namespace etc. */
    entryId: EntryId;
    /** User-defined key. You can re-use a key to replace it with new contents. */
    key?: string | undefined;
    /** User-defined title. */
    title?: string | undefined;
    /** User-defined metadata. */
    metadata?: Metadata | undefined;
    /** How important this entry is. Defaults to 1.
     * Think of it as multiplying by the vector search score.
     */
    importance: number;
    /** Filters that can be used to search for this entry.
     * Up to 4 filters are supported, of any type.
     */
    filterValues: EntryFilter<Filters>[];
    /** Hash of the entry contents.
     * If supplied, it will avoid adding if the hash is the same.
     */
    contentHash?: string | undefined;
} & ({
    /** Whether this entry's contents have all been inserted and indexed. */
    status: "pending" | "ready";
} | {
    status: "replaced";
    replacedAt: number;
});
export declare const vChunk: VObject<{
    metadata?: Record<string, any> | undefined;
    order: number;
    text: string;
    state: "pending" | "ready" | "replaced";
}, {
    order: import("convex/values").VFloat64<number, "required">;
    state: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
    text: import("convex/values").VString<string, "required">;
    metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
}, "required", "order" | "text" | "metadata" | `metadata.${string}` | "state">;
export type Chunk = Infer<typeof vChunk>;
export declare const vCreateChunkArgs: VObject<{
    searchableText?: string | undefined;
    content: {
        metadata?: Record<string, any> | undefined;
        text: string;
    };
    embedding: number[];
}, {
    content: VObject<{
        metadata?: Record<string, any> | undefined;
        text: string;
    }, {
        text: import("convex/values").VString<string, "required">;
        metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
    }, "required", "text" | "metadata" | `metadata.${string}`>;
    embedding: import("convex/values").VArray<number[], import("convex/values").VFloat64<number, "required">, "required">;
    searchableText: import("convex/values").VString<string | undefined, "optional">;
}, "required", "content" | "embedding" | "searchableText" | "content.text" | "content.metadata" | `content.metadata.${string}`>;
export type CreateChunkArgs = Infer<typeof vCreateChunkArgs>;
export declare function vPaginationResult<T extends Validator<Value, "required", string>>(itemValidator: T): VObject<{
    splitCursor?: string | null | undefined;
    pageStatus?: "SplitRecommended" | "SplitRequired" | null | undefined;
    page: T["type"][];
    continueCursor: string;
    isDone: boolean;
}, {
    page: import("convex/values").VArray<T["type"][], T, "required">;
    continueCursor: import("convex/values").VString<string, "required">;
    isDone: import("convex/values").VBoolean<boolean, "required">;
    splitCursor: import("convex/values").VUnion<string | null | undefined, [import("convex/values").VString<string, "required">, import("convex/values").VNull<null, "required">], "optional", never>;
    pageStatus: import("convex/values").VUnion<"SplitRecommended" | "SplitRequired" | null | undefined, [import("convex/values").VLiteral<"SplitRecommended", "required">, import("convex/values").VLiteral<"SplitRequired", "required">, import("convex/values").VNull<null, "required">], "optional", never>;
}, "required", "page" | "continueCursor" | "isDone" | "splitCursor" | "pageStatus">;
export type OnCompleteNamespace = FunctionReference<"mutation", "internal", {
    namespace: Namespace;
    replacedNamespace: Namespace | null;
}, null, string>;
export declare const vOnCompleteArgs: VObject<{
    replacedEntry?: {
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        replacedAt?: number | undefined;
        entryId: string & {
            _: "EntryId";
        };
        status: "pending" | "ready" | "replaced";
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    } | undefined;
    error?: string | undefined;
    namespace: {
        namespaceId: string & {
            _: "NamespaceId";
        };
        createdAt: number;
        namespace: string;
        status: "pending" | "ready" | "replaced";
        filterNames: string[];
        dimension: number;
        modelId: string;
        version: number;
    };
    entry: {
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        replacedAt?: number | undefined;
        entryId: string & {
            _: "EntryId";
        };
        status: "pending" | "ready" | "replaced";
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    };
}, {
    namespace: VObject<{
        namespaceId: string & {
            _: "NamespaceId";
        };
        createdAt: number;
        namespace: string;
        status: "pending" | "ready" | "replaced";
        filterNames: string[];
        dimension: number;
        modelId: string;
        version: number;
    }, {
        namespaceId: import("convex/values").VString<string & {
            _: "NamespaceId";
        }, "required">;
        createdAt: import("convex/values").VFloat64<number, "required">;
        namespace: import("convex/values").VString<string, "required">;
        status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
        filterNames: import("convex/values").VArray<string[], import("convex/values").VString<string, "required">, "required">;
        dimension: import("convex/values").VFloat64<number, "required">;
        modelId: import("convex/values").VString<string, "required">;
        version: import("convex/values").VFloat64<number, "required">;
    }, "required", "namespaceId" | "createdAt" | "namespace" | "status" | "filterNames" | "dimension" | "modelId" | "version">;
    entry: VObject<{
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        replacedAt?: number | undefined;
        entryId: string & {
            _: "EntryId";
        };
        status: "pending" | "ready" | "replaced";
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    }, {
        key: import("convex/values").VString<string | undefined, "optional">;
        title: import("convex/values").VString<string | undefined, "optional">;
        metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
        entryId: import("convex/values").VString<string & {
            _: "EntryId";
        }, "required">;
        importance: import("convex/values").VFloat64<number, "required">;
        filterValues: import("convex/values").VArray<{
            name: string;
            value: any;
        }[], VObject<{
            name: string;
            value: any;
        }, {
            name: import("convex/values").VString<string, "required">;
            value: import("convex/values").VAny<any, "required", string>;
        }, "required", "name" | "value" | `value.${string}`>, "required">;
        contentHash: import("convex/values").VString<string | undefined, "optional">;
        status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
        replacedAt: import("convex/values").VFloat64<number | undefined, "optional">;
    }, "required", "entryId" | "metadata" | `metadata.${string}` | "status" | "key" | "title" | "importance" | "filterValues" | "contentHash" | "replacedAt">;
    replacedEntry: VObject<{
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        replacedAt?: number | undefined;
        entryId: string & {
            _: "EntryId";
        };
        status: "pending" | "ready" | "replaced";
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    } | undefined, {
        key: import("convex/values").VString<string | undefined, "optional">;
        title: import("convex/values").VString<string | undefined, "optional">;
        metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
        entryId: import("convex/values").VString<string & {
            _: "EntryId";
        }, "required">;
        importance: import("convex/values").VFloat64<number, "required">;
        filterValues: import("convex/values").VArray<{
            name: string;
            value: any;
        }[], VObject<{
            name: string;
            value: any;
        }, {
            name: import("convex/values").VString<string, "required">;
            value: import("convex/values").VAny<any, "required", string>;
        }, "required", "name" | "value" | `value.${string}`>, "required">;
        contentHash: import("convex/values").VString<string | undefined, "optional">;
        status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
        replacedAt: import("convex/values").VFloat64<number | undefined, "optional">;
    }, "optional", "entryId" | "metadata" | `metadata.${string}` | "status" | "key" | "title" | "importance" | "filterValues" | "contentHash" | "replacedAt">;
    error: import("convex/values").VString<string | undefined, "optional">;
}, "required", "namespace" | "entry" | "replacedEntry" | "error" | "namespace.namespaceId" | "namespace.createdAt" | "namespace.namespace" | "namespace.status" | "namespace.filterNames" | "namespace.dimension" | "namespace.modelId" | "namespace.version" | "entry.entryId" | "entry.metadata" | `entry.metadata.${string}` | "entry.status" | "entry.key" | "entry.title" | "entry.importance" | "entry.filterValues" | "entry.contentHash" | "entry.replacedAt" | "replacedEntry.entryId" | "replacedEntry.metadata" | `replacedEntry.metadata.${string}` | "replacedEntry.status" | "replacedEntry.key" | "replacedEntry.title" | "replacedEntry.importance" | "replacedEntry.filterValues" | "replacedEntry.contentHash" | "replacedEntry.replacedAt">;
export type OnCompleteArgs<Filters extends Record<string, Value> = any, EntryMetadata extends Record<string, Value> = any> = {
    /**
     * The namespace that the entry belongs to.
     */
    namespace: Namespace;
    /**
     * The entry that was added.
     */
    entry: Entry<Filters, EntryMetadata>;
    /**
     * The previous "ready" entry with the same key that was replaced.
     */
    replacedEntry: Entry<Filters, EntryMetadata> | undefined;
    /**
     * If async generation failed, this is the error.
     */
    error: string | undefined;
};
export type OnComplete = FunctionReference<"mutation", "internal", IdsToStrings<Infer<typeof vOnCompleteArgs>>, null>;
export declare const vChunkerArgs: VObject<{
    namespace: {
        namespaceId: string & {
            _: "NamespaceId";
        };
        createdAt: number;
        namespace: string;
        status: "pending" | "ready" | "replaced";
        filterNames: string[];
        dimension: number;
        modelId: string;
        version: number;
    };
    entry: {
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        replacedAt?: number | undefined;
        entryId: string & {
            _: "EntryId";
        };
        status: "pending" | "ready" | "replaced";
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    };
    insertChunks: string;
}, {
    namespace: VObject<{
        namespaceId: string & {
            _: "NamespaceId";
        };
        createdAt: number;
        namespace: string;
        status: "pending" | "ready" | "replaced";
        filterNames: string[];
        dimension: number;
        modelId: string;
        version: number;
    }, {
        namespaceId: import("convex/values").VString<string & {
            _: "NamespaceId";
        }, "required">;
        createdAt: import("convex/values").VFloat64<number, "required">;
        namespace: import("convex/values").VString<string, "required">;
        status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
        filterNames: import("convex/values").VArray<string[], import("convex/values").VString<string, "required">, "required">;
        dimension: import("convex/values").VFloat64<number, "required">;
        modelId: import("convex/values").VString<string, "required">;
        version: import("convex/values").VFloat64<number, "required">;
    }, "required", "namespaceId" | "createdAt" | "namespace" | "status" | "filterNames" | "dimension" | "modelId" | "version">;
    entry: VObject<{
        metadata?: Record<string, any> | undefined;
        key?: string | undefined;
        title?: string | undefined;
        contentHash?: string | undefined;
        replacedAt?: number | undefined;
        entryId: string & {
            _: "EntryId";
        };
        status: "pending" | "ready" | "replaced";
        importance: number;
        filterValues: {
            name: string;
            value: any;
        }[];
    }, {
        key: import("convex/values").VString<string | undefined, "optional">;
        title: import("convex/values").VString<string | undefined, "optional">;
        metadata: import("convex/values").VRecord<Record<string, any> | undefined, import("convex/values").VString<string, "required">, import("convex/values").VAny<any, "required", string>, "optional", string>;
        entryId: import("convex/values").VString<string & {
            _: "EntryId";
        }, "required">;
        importance: import("convex/values").VFloat64<number, "required">;
        filterValues: import("convex/values").VArray<{
            name: string;
            value: any;
        }[], VObject<{
            name: string;
            value: any;
        }, {
            name: import("convex/values").VString<string, "required">;
            value: import("convex/values").VAny<any, "required", string>;
        }, "required", "name" | "value" | `value.${string}`>, "required">;
        contentHash: import("convex/values").VString<string | undefined, "optional">;
        status: import("convex/values").VUnion<"pending" | "ready" | "replaced", [import("convex/values").VLiteral<"pending", "required">, import("convex/values").VLiteral<"ready", "required">, import("convex/values").VLiteral<"replaced", "required">], "required", never>;
        replacedAt: import("convex/values").VFloat64<number | undefined, "optional">;
    }, "required", "entryId" | "metadata" | `metadata.${string}` | "status" | "key" | "title" | "importance" | "filterValues" | "contentHash" | "replacedAt">;
    insertChunks: import("convex/values").VString<string, "required">;
}, "required", "namespace" | "entry" | "namespace.namespaceId" | "namespace.createdAt" | "namespace.namespace" | "namespace.status" | "namespace.filterNames" | "namespace.dimension" | "namespace.modelId" | "namespace.version" | "entry.entryId" | "entry.metadata" | `entry.metadata.${string}` | "entry.status" | "entry.key" | "entry.title" | "entry.importance" | "entry.filterValues" | "entry.contentHash" | "entry.replacedAt" | "insertChunks">;
export type ChunkerAction = FunctionReference<"action", "internal", IdsToStrings<Infer<typeof vChunkerArgs>>, null>;
/**
 * Check if the args filter names are compatible with the existing filter names.
 * @param existing The existing filter names.
 * @param args The filter names to check. Can be a prefix
 * @returns True if the filter names are the same, in the same order.
 */
export declare function filterNamesContain(existing: string[], args: string[]): boolean;
type IdsToStrings<T> = T extends GenericId<string> ? string : T extends (infer U)[] ? IdsToStrings<U>[] : T extends Record<string, Value | undefined> ? {
    [K in keyof T]: IdsToStrings<T[K]>;
} : T;
export {};
//# sourceMappingURL=shared.d.ts.map