import { v } from "convex/values";
import { vNamedFilter } from "./component/filters.js";
import { brandedString } from "convex-helpers/validators";
// A good middle-ground that has up to ~3MB if embeddings are 4096 (max).
// Also a reasonable number of writes to the DB.
export const CHUNK_BATCH_SIZE = 100;
// Branded types for IDs, as components don't expose the internal ID types.
export const vNamespaceId = brandedString("NamespaceId");
export const vEntryId = brandedString("EntryId");
export const vSearchResult = v.object({
    entryId: vEntryId,
    order: v.number(),
    content: v.array(v.object({
        text: v.string(),
        metadata: v.optional(v.record(v.string(), v.any())),
    })),
    startOrder: v.number(),
    score: v.number(),
});
export const vStatus = v.union(v.literal("pending"), v.literal("ready"), v.literal("replaced"));
export const vActiveStatus = v.union(v.literal("pending"), v.literal("ready"));
export const statuses = vStatus.members.map((s) => s.value);
export const vNamespace = v.object({
    namespaceId: vNamespaceId,
    createdAt: v.number(),
    namespace: v.string(),
    status: vStatus,
    filterNames: v.array(v.string()),
    dimension: v.number(),
    modelId: v.string(),
    version: v.number(),
});
export const vEntry = v.object({
    key: v.optional(v.string()),
    title: v.optional(v.string()),
    metadata: v.optional(v.record(v.string(), v.any())),
    entryId: vEntryId,
    importance: v.number(),
    filterValues: v.array(vNamedFilter),
    contentHash: v.optional(v.string()),
    status: vStatus,
    replacedAt: v.optional(v.number()),
});
// Type assertion to keep us honest (modulo the replacedAt field)
const _1 = {};
const _2 = {};
export const vSearchEntry = v.object({ ...vEntry.fields, text: v.string() });
export const vChunk = v.object({
    order: v.number(),
    state: vStatus,
    text: v.string(),
    metadata: v.optional(v.record(v.string(), v.any())),
});
export const vCreateChunkArgs = v.object({
    content: v.object({
        text: v.string(),
        metadata: v.optional(v.record(v.string(), v.any())),
    }),
    embedding: v.array(v.number()),
    searchableText: v.optional(v.string()),
});
export function vPaginationResult(itemValidator) {
    return v.object({
        page: v.array(itemValidator),
        continueCursor: v.string(),
        isDone: v.boolean(),
        splitCursor: v.optional(v.union(v.string(), v.null())),
        pageStatus: v.optional(v.union(v.literal("SplitRecommended"), v.literal("SplitRequired"), v.null())),
    });
}
export const vOnCompleteArgs = v.object({
    namespace: vNamespace,
    entry: vEntry,
    replacedEntry: v.optional(vEntry),
    error: v.optional(v.string()),
});
export const vChunkerArgs = v.object({
    namespace: vNamespace,
    entry: vEntry,
    insertChunks: v.string(),
});
/**
 * Check if the args filter names are compatible with the existing filter names.
 * @param existing The existing filter names.
 * @param args The filter names to check. Can be a prefix
 * @returns True if the filter names are the same, in the same order.
 */
export function filterNamesContain(existing, args) {
    for (const name of args) {
        if (!existing.includes(name)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=shared.js.map