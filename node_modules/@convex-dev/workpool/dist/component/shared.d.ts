import type { Infer } from "convex/values";
import { type Logger } from "./logging.js";
export declare const fnType: import("convex/values").VUnion<"mutation" | "query" | "action", [import("convex/values").VLiteral<"action", "required">, import("convex/values").VLiteral<"mutation", "required">, import("convex/values").VLiteral<"query", "required">], "required", never>;
export declare const DEFAULT_MAX_PARALLELISM = 10;
export declare const SECOND = 1000;
export declare const MINUTE: number;
export declare const HOUR: number;
export declare const DAY: number;
export declare const YEAR: number;
export declare function toSegment(ms: number): bigint;
export declare function getCurrentSegment(): bigint;
export declare function getNextSegment(): bigint;
export declare function fromSegment(segment: bigint): number;
export declare const config: import("convex/values").VObject<{
    logLevel: "DEBUG" | "TRACE" | "INFO" | "REPORT" | "WARN" | "ERROR";
    maxParallelism: number;
}, {
    maxParallelism: import("convex/values").VFloat64<number, "required">;
    logLevel: import("convex/values").VUnion<"DEBUG" | "TRACE" | "INFO" | "REPORT" | "WARN" | "ERROR", [import("convex/values").VLiteral<"DEBUG", "required">, import("convex/values").VLiteral<"TRACE", "required">, import("convex/values").VLiteral<"INFO", "required">, import("convex/values").VLiteral<"REPORT", "required">, import("convex/values").VLiteral<"WARN", "required">, import("convex/values").VLiteral<"ERROR", "required">], "required", never>;
}, "required", "logLevel" | "maxParallelism">;
export type Config = Infer<typeof config>;
export declare const retryBehavior: import("convex/values").VObject<{
    maxAttempts: number;
    initialBackoffMs: number;
    base: number;
}, {
    maxAttempts: import("convex/values").VFloat64<number, "required">;
    initialBackoffMs: import("convex/values").VFloat64<number, "required">;
    base: import("convex/values").VFloat64<number, "required">;
}, "required", "maxAttempts" | "initialBackoffMs" | "base">;
export type RetryBehavior = {
    /**
     * The maximum number of attempts to make. 2 means one retry.
     */
    maxAttempts: number;
    /**
     * The initial backoff time in milliseconds. 100 means wait 100ms before the
     * first retry.
     */
    initialBackoffMs: number;
    /**
     * The base for the backoff. 2 means double the backoff each time.
     * e.g. if the initial backoff is 100ms, and the base is 2, then the first
     * retry will wait 200ms, the second will wait 400ms, etc.
     */
    base: number;
};
export declare const DEFAULT_RETRY_BEHAVIOR: RetryBehavior;
export declare const vResultValidator: import("convex/values").VUnion<{
    kind: "success";
    returnValue: any;
} | {
    kind: "failed";
    error: string;
} | {
    kind: "canceled";
}, [import("convex/values").VObject<{
    kind: "success";
    returnValue: any;
}, {
    kind: import("convex/values").VLiteral<"success", "required">;
    returnValue: import("convex/values").VAny<any, "required", string>;
}, "required", "kind" | "returnValue" | `returnValue.${string}`>, import("convex/values").VObject<{
    kind: "failed";
    error: string;
}, {
    kind: import("convex/values").VLiteral<"failed", "required">;
    error: import("convex/values").VString<string, "required">;
}, "required", "kind" | "error">, import("convex/values").VObject<{
    kind: "canceled";
}, {
    kind: import("convex/values").VLiteral<"canceled", "required">;
}, "required", "kind">], "required", "kind" | "returnValue" | `returnValue.${string}` | "error">;
export type RunResult = Infer<typeof vResultValidator>;
export declare const onComplete: import("convex/values").VObject<{
    context?: any;
    fnHandle: string;
}, {
    fnHandle: import("convex/values").VString<string, "required">;
    context: import("convex/values").VAny<any, "optional", string>;
}, "required", "fnHandle" | "context" | `context.${string}`>;
export type OnComplete = Infer<typeof onComplete>;
export type OnCompleteArgs = {
    /**
     * The ID of the work that completed.
     */
    workId: string;
    /**
     * The context object passed when enqueuing the work.
     * Useful for passing data from the enqueue site to the onComplete site.
     */
    context: unknown;
    /**
     * The result of the run that completed.
     */
    result: RunResult;
};
export declare const status: import("convex/values").VUnion<{
    state: "pending";
    previousAttempts: number;
} | {
    state: "running";
    previousAttempts: number;
} | {
    state: "finished";
}, [import("convex/values").VUnion<{
    state: "pending";
    previousAttempts: number;
} | {
    state: "running";
    previousAttempts: number;
} | {
    state: "finished";
}, [import("convex/values").VObject<{
    state: "pending";
    previousAttempts: number;
}, {
    state: import("convex/values").VLiteral<"pending", "required">;
    previousAttempts: import("convex/values").VFloat64<number, "required">;
}, "required", "state" | "previousAttempts">, import("convex/values").VObject<{
    state: "running";
    previousAttempts: number;
}, {
    state: import("convex/values").VLiteral<"running", "required">;
    previousAttempts: import("convex/values").VFloat64<number, "required">;
}, "required", "state" | "previousAttempts">, import("convex/values").VObject<{
    state: "finished";
}, {
    state: import("convex/values").VLiteral<"finished", "required">;
}, "required", "state">], "required", "state" | "previousAttempts">], "required", "state" | "previousAttempts">;
export type Status = Infer<typeof status>;
export declare function boundScheduledTime(ms: number, console: Logger): number;
/**
 * Returns the smaller of two bigint values.
 */
export declare function min<T extends bigint>(a: T, b: T): T;
/**
 * Returns the larger of two bigint values.
 */
export declare function max<T extends bigint>(a: T, b: T): T;
//# sourceMappingURL=shared.d.ts.map